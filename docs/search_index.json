[["tidymodels.html", "Kapitel 6 tidymodels 6.1 Lernsteuerung 6.2 Daten 6.3 Train- vs Test-Datensatz aufteilen 6.4 Grundlagen der Modellierung mit tidymodels 6.5 Workflows 6.6 Rezepte zur Vorverarbeitung 6.7 Aufgaben", " Kapitel 6 tidymodels Benötigte R-Pakete für dieses Kapitel: library(tidyverse) library(tidymodels) 6.1 Lernsteuerung 6.1.1 Vorbereitung Lesen Sie TMWR, Kapitel 1 Lesen Sie übrige Literatur zu diesem Thema 6.1.2 Lernziele Sie sind in der Lage, Regressionsmodelle mit dem tidymodels-Ansatz zu spezifizieren 6.1.3 Literatur TMWR, Kap. 1, 5, 6, 7, 8, 9 6.2 Daten Dieser Abschnitt bezieht sich auf Kapitel 4 in Silge and Kuhn (2022). Wir benutzen den Datensatz zu Immobilienpreise aus dem Ames County in Iowa, USA, gelegen im Zentrum des Landes. data(ames) # Daten wurden über tidymodels mit geladen ames &lt;- ames %&gt;% mutate(Sale_Price = log10(Sale_Price)) Hier wurde die AV log-transformiert. Das hat zwei (wichtige) Effekte: Die Verteilung ist symmetrischer, näher an der Normalverteilung. Damit gibt es mehr Daten im Hauptbereich des Ranges von Sale_Price, was die Vorhersagen stabiler machen dürfte. Logarithmiert man die Y-Variable, so kommt dies einem multiplikativen Modell gleich, s. auch hier. 6.3 Train- vs Test-Datensatz aufteilen Dieser Abschnitt bezieht sich auf Kapitel 5 in Silge and Kuhn (2022). Das Aufteilen in Train- und Test-Datensatz ist einer der wesentlichen Grundsätze im maschinellen Lernen. Das Ziel ist, Overfitting abzuwenden. Im Train-Datensatz werden alle Modelle berechnet. Der Test-Datensatz wird nur einmal verwendet, und zwar zur Überprüfung der Modellgüte. Praktisch funktioniert das in Silge and Kuhn (2022) wie folgt. Wir laden die Daten und erstellen einen Index, der jeder Beobachtung die Zuteilung zu Train- bzw. zum Test-Datensatz zuweist: ames_split &lt;- initial_split(ames, prop = 0.80, strata = Sale_Price) initial_split() speichert für spätere komfortable Verwendung auch die Daten. Aber eben auch der Index, der bestimmt, welche Beobachtung im Train-Set landet: ames_split$in_id %&gt;% head(n = 10) ## [1] 2 27 28 30 31 32 33 35 78 79 length(ames_split$in_id) ## [1] 2342 Praktisch ist auch, dass die AV-Verteilung in beiden Datensätzen ähnlich gehalten wird (Stratifizierung), das besorgt das Argument strata. Die eigentlich Aufteilung in die zwei Datensätze geht dann so: ames_train &lt;- training(ames_split) ames_test &lt;- testing(ames_split) 6.4 Grundlagen der Modellierung mit tidymodels Dieser Abschnitt bezieht sich auf Kapitel 6 in Silge and Kuhn (2022). tidymodels ist eine Sammlung mehrerer, zusammengehöriger Pakete, eben zum Thema statistische Modellieren. Das kann man analog zur Sammlung tidyverse verstehen, zu der z.B. das R-Paket dplyr gehört. Das R-Paket innerhalb von tidymodels, das zum “Fitten” von Modellen zuständig ist, heißt parsnip. Eine Liste der verfügbaren Modelltypen, Modellimplementierungen und Modellparameter, die in Parsnip aktuell unterstützt werden, findet sich hier. 6.4.1 Modelle spezifizieren Ein (statistisches) Modell wird in Tidymodels mit drei Elementen spezifiziert, vgl. Abb. 6.1. Figure 6.1: Definition eines Models in tidymodels Die Definition eines Modells in tidymodels folgt diesen Ideen: Das Modell sollte unabhängig von den Daten spezifiziert sein Das Modell sollte unabhängig von den Variablen (AV, UVs) spezifiziert sein Das Modell sollte unabhängig von etwaiger Vorverarbeitung (z.B. z-Transformation) spezifiziert sein Da bei einer linearen Regression nur der Modus “Regression” möglich ist, muss der Modus in diesem Fall nicht angegeben werden. Tidymodels erkennt das automatisch. lm_model &lt;- linear_reg() %&gt;% # Algorithmus, Modelltyp set_engine(&quot;lm&quot;) # Implementierung # Modus hier nicht nötig, da lineare Modelle immer numerisch klassifizieren 6.4.2 Modelle berechnen Nach Rhys (2020) ist ein Modell sogar erst ein Modell, wenn die Koeffizienten berechnet sind. Tidymodels kennt diese Unterscheidung nicht. Stattdessen spricht man in Tidymodels von einem “gefitteten” Modell, sobald es berechnet ist. Ähnlich fancy könnte man von einem “instantiierten” Modell sprechen. Für das Beispiel der einfachen linearen Regression heißt das, das Modell ist gefittet, sobald die Steigung und der Achsenabschnitt (sowie die Residualstreuung) berechnet sind. lm_form_fit &lt;- lm_model %&gt;% fit(Sale_Price ~ Longitude + Latitude, data = ames_train) 6.4.3 Vorhersagen Im maschinellen Lernen ist man primär an den Vorhersagen interessiert, häufig nur an Punktschätzungen. Schauen wir uns also zunächst diese an. Vorhersagen bekommt man recht einfach mit der predict() Methode: predict(lm_form_fit, new_data = ames_test) %&gt;% head() ## # A tibble: 6 × 1 ## .pred ## &lt;dbl&gt; ## 1 5.23 ## 2 5.29 ## 3 5.29 ## 4 5.28 ## 5 5.25 ## 6 5.32 Die Syntax lautet predict(modell, daten_zum_vorhersagen). 6.4.4 Vorhersagen im Train-Datensatz Vorhersagen im Train-Datensatz machen keinen Sinn, da sie nicht gegen Overfitting geschützt sind und daher deutlich zu optimistisch sein können. Bei einer linearen Regression ist diese Gefahr nicht so hoch, aber bei anderen, flexibleren Modellen, ist diese Gefahr absurd groß. 6.4.5 Modellkoeffizienten im Train-Datensatz Gibt man den Namen des Modellobjekts ein, so wird ein Überblick an relevanten Modellergebnissen am Bildschirm gedruckt: lm_form_fit ## parsnip model object ## ## ## Call: ## stats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data) ## ## Coefficients: ## (Intercept) Longitude Latitude ## -308.928 -2.004 3.008 Innerhalb des Ergebnisobjekts findet sich eine Liste namens fit, in der die Koeffizienten (der “Fit”) abgelegt sind: lm_form_fit %&gt;% pluck(&quot;fit&quot;) ## ## Call: ## stats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data) ## ## Coefficients: ## (Intercept) Longitude Latitude ## -308.928 -2.004 3.008 Zum Herausholen dieser Infos kann man auch die Funktion extract_fit_engine() verwenden: lm_fit &lt;- lm_form_fit %&gt;% extract_fit_engine() lm_fit ## ## Call: ## stats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data) ## ## Coefficients: ## (Intercept) Longitude Latitude ## -308.928 -2.004 3.008 Das extrahierte Objekt ist, in diesem Fall, das typische lm() Objekt. Entsprechend kann man daruaf coef() oder summary() anwenden. coef(lm_fit) ## (Intercept) Longitude Latitude ## -308.927662 -2.004393 3.008252 summary(lm_fit) ## ## Call: ## stats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.01995 -0.09882 -0.01772 0.09919 0.57668 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -308.9277 14.5448 -21.24 &lt;2e-16 *** ## Longitude -2.0044 0.1293 -15.50 &lt;2e-16 *** ## Latitude 3.0083 0.1819 16.54 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.1607 on 2339 degrees of freedom ## Multiple R-squared: 0.1751, Adjusted R-squared: 0.1744 ## F-statistic: 248.2 on 2 and 2339 DF, p-value: &lt; 2.2e-16 Schicker sind die Pendant-Befehle aus broom, die jeweils einen Tibble zuückliefern: library(broom) tidy(lm_fit) # Koeffizienten ## # A tibble: 3 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -309. 14.5 -21.2 1.09e-91 ## 2 Longitude -2.00 0.129 -15.5 1.16e-51 ## 3 Latitude 3.01 0.182 16.5 3.51e-58 glance(lm_fit) # Modellgüte ## # A tibble: 1 × 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.175 0.174 0.161 248. 1.71e-98 2 961. -1913. -1890. ## # … with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; 6.4.6 Parsnip RStudio add-in Mit dem Add-in von Parsnip kann man sich eine Modellspezifikation per Klick ausgeben lassen. Nett! parsnip_addin() 6.5 Workflows Dieser Abschnitt bezieht sich auf Kapitel 7 in Silge and Kuhn (2022). 6.5.1 Konzept des Workflows in Tidymodels Figure 6.2: Definition eines Models in tidymodels 6.5.2 Einfaches Beispiel Wir initialisieren einen Workflow, verzichten auf Vorverarbeitung und fügen ein Modell hinzu: lm_workflow &lt;- workflow() %&gt;% # init add_model(lm_model) %&gt;% # Modell hinzufügen add_formula(Sale_Price ~ Longitude + Latitude) # Modellformel hinzufügen Werfen wir einen Blick in das Workflow-Objekt: lm_workflow ## ══ Workflow ════════════════════════════════════════════════════════════════════ ## Preprocessor: Formula ## Model: linear_reg() ## ## ── Preprocessor ──────────────────────────────────────────────────────────────── ## Sale_Price ~ Longitude + Latitude ## ## ── Model ─────────────────────────────────────────────────────────────────────── ## Linear Regression Model Specification (regression) ## ## Computational engine: lm Wie man sieht, gehört die Modellformel (y ~ x) zur Vorverarbeitung aus Sicht von Tidymodels. Was war nochmal im Objekt lm_model enthalten? lm_model ## Linear Regression Model Specification (regression) ## ## Computational engine: lm Jetzt können wir das Modell berechnen (fitten): lm_fit &lt;- lm_workflow %&gt;% fit(ames_train) Natürlich kann man synonym auch schreiben: lm_fit &lt;- fit(lm_wflow, ames_train) Schauen wir uns das Ergebnis an: lm_fit ## ══ Workflow [trained] ══════════════════════════════════════════════════════════ ## Preprocessor: Formula ## Model: linear_reg() ## ## ── Preprocessor ──────────────────────────────────────────────────────────────── ## Sale_Price ~ Longitude + Latitude ## ## ── Model ─────────────────────────────────────────────────────────────────────── ## ## Call: ## stats::lm(formula = ..y ~ ., data = data) ## ## Coefficients: ## (Intercept) Longitude Latitude ## -308.928 -2.004 3.008 6.5.3 Vorhersage mit einem Workflow Die Vorhersage mit einem Tidymodels-Workflow ist einerseits komfortabel, da man einfach sagen kann: “Nimm die richtigen Koeffizienten des Modells aus dem Train-Set und wende sie auf das Test-Sample an. Berechne mir die Vorhersagen und die Modellgüte.” So sieht das aus: final_lm_res &lt;- last_fit(lm_workflow, ames_split) final_lm_res ## # Resampling results ## # Manual resampling ## # A tibble: 1 × 6 ## splits id .metrics .notes .predictions .workflow ## &lt;list&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 &lt;split [2342/588]&gt; train/test split &lt;tibble&gt; &lt;tibble&gt; &lt;tibble&gt; &lt;workflow&gt; Anderseits wird auch ein recht komplexes Objekt zurückgeliefert, das man erst mal durchschauen muss. Wie man sieht, gibt es mehrere Listenspalten. Besonders interessant erscheinen natürlich die Listenspalten .metrics und .predictions. Schauen wir uns die Vorhersagen an. lm_preds &lt;- final_lm_res %&gt;% pluck(&quot;.predictions&quot;, 1) Es gibt auch eine Funktion, die obige Zeile vereinfacht (also synonym ist): lm_preds &lt;- collect_predictions(final_lm_res) lm_preds %&gt;% slice_head(n = 5) ## # A tibble: 5 × 5 ## id .pred .row Sale_Price .config ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 train/test split 5.23 1 5.33 Preprocessor1_Model1 ## 2 train/test split 5.29 5 5.28 Preprocessor1_Model1 ## 3 train/test split 5.29 7 5.33 Preprocessor1_Model1 ## 4 train/test split 5.28 9 5.37 Preprocessor1_Model1 ## 5 train/test split 5.25 26 5.15 Preprocessor1_Model1 6.5.4 Modellgüte Dieser Abschnitt bezieht sich auf Kapitel 9 in Silge and Kuhn (2022). Die Vorhersagen bilden die Basis für die Modellgüte (“Metriken”), die schon fertig berechnet im Objekt final_lm_res liegen und mit collect_metrics herausgenommen werden können: lm_metrics &lt;- collect_metrics(final_lm_res) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #krpgkemwut .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #krpgkemwut .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #krpgkemwut .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #krpgkemwut .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #krpgkemwut .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #krpgkemwut .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #krpgkemwut .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #krpgkemwut .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #krpgkemwut .gt_column_spanner_outer:first-child { padding-left: 0; } #krpgkemwut .gt_column_spanner_outer:last-child { padding-right: 0; } #krpgkemwut .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #krpgkemwut .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #krpgkemwut .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #krpgkemwut .gt_from_md > :first-child { margin-top: 0; } #krpgkemwut .gt_from_md > :last-child { margin-bottom: 0; } #krpgkemwut .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #krpgkemwut .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #krpgkemwut .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #krpgkemwut .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #krpgkemwut .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #krpgkemwut .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #krpgkemwut .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #krpgkemwut .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #krpgkemwut .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #krpgkemwut .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #krpgkemwut .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #krpgkemwut .gt_sourcenote { font-size: 90%; padding: 4px; } #krpgkemwut .gt_left { text-align: left; } #krpgkemwut .gt_center { text-align: center; } #krpgkemwut .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #krpgkemwut .gt_font_normal { font-weight: normal; } #krpgkemwut .gt_font_bold { font-weight: bold; } #krpgkemwut .gt_font_italic { font-style: italic; } #krpgkemwut .gt_super { font-size: 65%; } #krpgkemwut .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } .metric .estimator .estimate .config rmse standard 1.63 &times; 10&minus;1 Preprocessor1_Model1 rsq standard 1.61 &times; 10&minus;1 Preprocessor1_Model1 Man kann auch angeben, welche Metriken der Modellgüte man bekommen möchte: ames_metrics &lt;- metric_set(rmse, rsq, mae) ames_metrics(data = lm_preds, truth = Sale_Price, estimate = .pred) ## # A tibble: 3 × 3 ## .metric .estimator .estimate ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 rmse standard 0.163 ## 2 rsq standard 0.161 ## 3 mae standard 0.125 6.5.5 Vorhersage von Hand Man kann sich die Metriken auch von Hand ausgeben lassen, wenn man direktere Kontrolle haben möchte als mit last_fit und collect_metrics. ames_test_small &lt;- ames_test %&gt;% slice(1:5) predict(lm_form_fit, new_data = ames_test_small) ## # A tibble: 5 × 1 ## .pred ## &lt;dbl&gt; ## 1 5.23 ## 2 5.29 ## 3 5.29 ## 4 5.28 ## 5 5.25 Jetzt binden wir die Spalten zusammen, also die “Wahrheit” (\\(y\\)) und die Vorhersagen: ames_test_small2 &lt;- ames_test_small %&gt;% select(Sale_Price) %&gt;% bind_cols(predict(lm_form_fit, ames_test_small)) %&gt;% # Add 95% prediction intervals to the results: bind_cols(predict(lm_form_fit, ames_test_small, type = &quot;pred_int&quot;)) rsq(ames_test_small2, truth = Sale_Price, estimate = .pred ) ## # A tibble: 1 × 3 ## .metric .estimator .estimate ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 rsq standard 0.0476 Andere Koeffizienten der Modellgüte können mit rmse oder mae abgerufen werden. 6.6 Rezepte zur Vorverarbeitung Dieser Abschnitt bezieht sich auf Kapitel 8 in Silge and Kuhn (2022). 6.6.1 Was ist Rezept und wozu ist es gut? So könnte ein typischer Aufruf von lm() aussehen: lm(Sale_Price ~ Neighborhood + log10(Gr_Liv_Area) + Year_Built + Bldg_Type, data = ames) Neben dem Fitten des Modells besorgt die Formel-Schreibweise noch einige zusätzliche nützliche Vorarbeitung: Definition von AV und AV Log-Transformation von Gr_Liv_Area Transformation der nominalen Variablen in Dummy-Variablen Das ist schön und nütlich, hat aber auch Nachteile: Das Modell wird nicht nur spezifiziert, sondern auch gleich berechnet. Das ist unpraktisch, weil man die Modellformel vielleicht in anderen Modell wiederverwenden möchte. Außerdem kann das Berechnen lange dauern. Die Schritte sind ineinander vermengt, so dass man nicht einfach und übersichtlich die einzelnen Schritte bearbeiten kann. Praktischer wäre also, die Schritte der Vorverarbeitung zu ent-flechten. Das geht mit einem “Rezept” aus Tidmoodels: simple_ames &lt;- recipe(Sale_Price ~ Neighborhood + Gr_Liv_Area + Year_Built + Bldg_Type, data = ames_train) %&gt;% step_log(Gr_Liv_Area, base = 10) %&gt;% step_dummy(all_nominal_predictors()) simple_ames ## Recipe ## ## Inputs: ## ## role #variables ## outcome 1 ## predictor 4 ## ## Operations: ## ## Log transformation on Gr_Liv_Area ## Dummy variables from all_nominal_predictors() Ein Rezept berechnet kein Modell. Es macht nichts außer die Vorverarbeitung des Modells zu spezizifieren (inklusive der Modellformel). 6.6.2 Workflows mit Rezepten Jetzt definieren wir den Workflow nicht nur mit einer Modellformel, sondern mit einem Rezept: lm_workflow &lt;- workflow() %&gt;% add_model(lm_model) %&gt;% add_recipe(simple_ames) Sonst hat sich nichts geändert. Wie vorher, können wir jetzt das Modell berechnen. lm_fit &lt;- fit(lm_workflow, ames_train) final_lm_res &lt;- last_fit(lm_workflow, ames_split) final_lm_res ## # Resampling results ## # Manual resampling ## # A tibble: 1 × 6 ## splits id .metrics .notes .predictions .workflow ## &lt;list&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 &lt;split [2342/588]&gt; train/test split &lt;tibble&gt; &lt;tibble&gt; &lt;tibble&gt; &lt;workflow&gt; ## ## There were issues with some computations: ## ## - Warning(s) x1: prediction from a rank-deficient fit may be misleading ## ## Use `collect_notes(object)` for more information. lm_metrics &lt;- collect_metrics(final_lm_res) lm_metrics ## # A tibble: 2 × 4 ## .metric .estimator .estimate .config ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 rmse standard 0.0833 Preprocessor1_Model1 ## 2 rsq standard 0.781 Preprocessor1_Model1 6.6.3 Spaltenrollen Eine praktische Funktion ist es, bestimmte Spalten nicht als Prädiktor, sondern als ID-Variable zu nutzen. Das kann man in Tidymodels komfortabel wie folgt angeben: ames_recipe &lt;- simple_ames %&gt;% update_role(Neighborhood, new_role = &quot;id&quot;) ames_recipe ## Recipe ## ## Inputs: ## ## role #variables ## id 1 ## outcome 1 ## predictor 3 ## ## Operations: ## ## Log transformation on Gr_Liv_Area ## Dummy variables from all_nominal_predictors() 6.6.4 Fazit Mehr zu Rezepten findet sich hier. Ein Überblick zu allen Schritten der Vorverarbeitung findet sich hier. 6.7 Aufgaben Fallstudie Seegurken References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
