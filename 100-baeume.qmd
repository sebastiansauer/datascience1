
# Entscheidungsb√§ume




## Lernsteuerung

### Lernziele


- Sie k√∂nnen den rpart-Algorithmus erkl√§ren
- Sie wissen, wie man Overfitting bei Entscheidungsb√§ume begrenzen kann
- Sie k√∂nnen Entscheidungsb√§ume in R berechnen
   
   
### Literatur

- Rhys, Kap. 7






### Vorbereitung


In diesem Kapitel werden folgende R-Pakete ben√∂tigt:

```{r echo = TRUE}
library(titanic)  # Datensatzt Titanic
#library(rpart)  # Berechnung von Entscheidungsb√§umen
library(tidymodels)
library(tictoc)  # Zeitmessung
library(readr)  # rds
```


```{r echo = FALSE}
titanic_train$Survived = as.factor(titanic_train$Survived)

ti_tree <-
  decision_tree() %>%
  set_engine("rpart") %>%
  set_mode("classification") %>%
  fit(Survived ~ Pclass + Age, data = titanic_train)
```



## Entscheidungb√§ume

### Anatomie eines Baumes

Ein Baum üå≥ hat (u.a.):

- Wurzel
- Bl√§tter
- √Ñste


In einem *Entscheidungsbaum* ist die Terminologie √§hnlich, s.  @fig-rec-part2.
Allgemein gesagt, kann ein Entscheidungsbaum in einem baum√§hnlichen Graphen visualisiert werden.
Dort gibt es Knoten, die durch Kanten verbunden sind,
wobei zu einem Knoten genau ein Kanten f√ºhrt. 


Ein  Beispiel f√ºr einen einfachen Baum sowie die zugeh√∂rige *rekursive Partionierung* ist in  @fig-rec-part2 dargestellt; 
man erkennt $R=3$ *Regionen* bzw. Bl√§tter [@islr].



:::{#fig-rec-part2 layout-ncol=2}

![Ein einfacher Baum](img/8.1.png){#fig-rec-2a}

![Die rekursiven, rechteckigen Partionierungen eines Baumes](img/8.2.png){#fig-rec-2b}

Einfaches Beispiel f√ºr einen Baum sowie der zugeh√∂rigen rekursiven Partionierung
:::



In  @fig-rec-part2 wird der Knoten an der Spitze auch als *Wurzel(knoten)* bezeichnet.
Von diesem Knoten entspringen alle Pfade.
Ein Pfad ist die geordnete Menge der Pfade mit ihren Knoten ausgehend von der Wurzel bis zu einem Blatt.
Knoten, aus denen kein Kanten mehr wegf√ºhrt ("Endknoten") werden als *Bl√§tter* bezeichnet.
Von einem Knoten gehen zwei Kanten aus (oder gar keine).
Knoten, von denen zwei Kanten ausgehen, spiegeln eine *Bedingung* (Pr√ºfung) wider, im Sinne einer Aussage,
die mit ja oder nein beantwortet werden kann.
Die Anzahl der Knoten eines Pfads entsprechen den *Ebenen* bzw. der Tiefe des Baumes.
Von der obersten Ebene (Wurzelknoten) kann man die $e$ Ebenen aufsteigend durchnummerieren,
beginnend bei 1: $1,2,\ldots,e$.


### B√§ume als Regelmaschinen rekursiver Partionierung

Ein Baum kann man als eine Menge von *Regeln*, im Sinne von *Wenn-dann-sonst-Aussagen*, sehen:

```
Wenn Pr√§diktor A = 1 ist dann
|  Wenn Pr√§diktor B = 0 ist dann p = 10%
|  sonst p = 30%
sonst p = 50%
```

In diesem Fall, zwei Pr√§diktoren, ist der Pr√§diktorenraum in *drei Regionen* unterteilt:
Der Baum hat drei Bl√§tter.

F√ºr  @fig-tree1 ergibt sich eine komplexere Aufteilung, s. auch  @fig-recursive-part.^[mit `library(rpart.plot)`]




```{r fig.cap = "Beispiel f√ºr einen Entscheidungsbaum", echo = FALSE}
#| label: fig-tree1

library(rpart.plot)

#knitr::include_graphics("img/tree-titanic.png")

rpart.plot(ti_tree[["fit"]], 
           box.palette="RdBu", 
           shadow.col="gray")
```

Kleine Lesehilfe f√ºr  @fig-tree1:

- F√ºr jeden Knoten steht in der ersten Zeile der vorhergesagte Wert, z.B. `0` im Wurzelknoten
- darunter steht der Anteil (die Wahrscheinlichkeit) f√ºr die in diesem Knoten vorhergesagte Kategorie (`0` oder `1`)
- darunter (3. Zeile) steht der Anteil der F√§lle (am Gesamt-Datensatz) in diesem Knoten, z.B. `100%`


```{r recursive-part, fig.cap = "Partionierung in Rechtecke durch Entscheidungsb√§ume", echo = FALSE}
#| label: fig-recursive-part
knitr::include_graphics("img/recursive-part.png")
```


Wie der Algorithmus oben zeigt,
wird der Pr√§diktorraum wiederholt (rekursiv) aufgeteilt,
und zwar in Rechtecke,s.  @fig-recursive-part.
Man nennt (eine Implementierung) dieses Algorithmus auch *rpart*.


Das Regelwerk zum Baum aus  @fig-tree1 sieht so aus:

```{r message=FALSE, echo = TRUE, echo = FALSE}
#| label: fig-tree1
#| fig-cap: "Baum basierte Algorithmen erzeugen 'rechteckige' Vorhersagebereiche"

titanic_train$Survived = as.factor(titanic_train$Survived)

ti_tree <-
  decision_tree() %>%
  set_engine("rpart") %>%
  set_mode("classification") %>%
  fit(Survived ~ Pclass + Age, data = titanic_train)

ti_tree
```


Kleine Lesehilfe:
Ander Wurzel `root` des Baumes, Knoten `1)`haben wir 891 F√§lle,
von denen 342 *nicht* unserer Vorhersage `yval` entsprechen, also `loss` sind,
das ist ein Anteil, `(yprob)` von 0.38.
Unsere Vorhersage ist `0`, da das die Mehrheit in diesem Knoten ist,
dieser Anteil betr√§gt ca. 61%.
In der Klammer stehen also die Wahrscheinlichkeiten f√ºr alle Auspr√§gungen von Y:, `0` und `1`,
in diesem Fall.
Entsprechendes gilt f√ºr jeden weiteren Knoten.


Ein kurzer Check der H√§ufigkeit am Wurzelknoten:

```{r}
count(titanic_train, Survived)
```








Solche Entscheidungsb√§ume zu erstellen, ist nichts neues. 
Man kann sie mit einer einfachen Checkliste oder Entscheidungssystem vergleichen.
Der Unterschied zu Entscheidungsb√§umen im maschinellen Lernen ist nur,
dass die Regeln aus den Daten gelernt werden, man muss sie nicht vorab kennen.



Noch ein Beispiel ist in  @fig-tree3 gezeigt [@islr]: 
Oben links zeigt eine *unm√∂gliche* Partionierung (f√ºr einen Entscheidungsbaum). 
Oben rechts zeigt die Regionen, 
die sich durch den Entscheidungsbaum unten links ergeben.
Untenrechts ist der Baum in 3D dargestellt.


```{r tree3, fig.cap = "Ein weiteres Beispiel zur Darstellung von Entscheidungsb√§umen", echo = FALSE}
#| label: fig-tree3
knitr::include_graphics("img/8.3.png")
```




## Klassifikation


B√§ume k√∂nnen f√ºr Zwecke der Klassifikation (nominal skalierte AV) oder Regression (numerische AV) verwendet werden.
Betrachten wir zun√§chst die bin√§re Klassifikation, also f√ºr eine zweistufige (nominalskalierte) AV.
Das Ziel des Entscheidungsmodel-Algorithmus ist es,
zu Bl√§ttern zu kommen, die m√∂glichst "sortenrein" sind, 
sich also m√∂glichst klar f√ºr eine (der beiden) Klassen $A$ oder $B$ aussprechen.
Nach dem Motto: "Wenn Pr√§diktor 1 kleiner $x$ und wenn Pr√§diktor 2 gleich $y$,
dann handelt es sich beim vorliegenden Fall ziemlich sicher um Klasse $A$."


:::: {.infobox .quote}
Je homogener die Verteilung der AV pro Blatt, desto genauer die Vorhersagen.
:::


Unsere Vorhersage in einem Blatt entspricht der Merheit bzw. der h√§ufigsten Kategorie in diesem Blatt.


### Gini als Optimierungskriterium

Es gibt mehrere Kennzahlen, die zur Optimierung bzw. zur Entscheidung zum Aufbau des Entscheidungsbaum herangezogen werden.
Zwei √ºbliche sind der *Gini-Koeffizient* und die *Entropie*.
Bei Kennzahlen sind Ma√ü f√ºr die Homogenit√§t oder "Sortenreinheit" (vs. Heterogenit√§t, engl. auch impurity).

Den Algorithmus zur Erzeugung des Baumes kann man so darstellen:

```
Wiederhole f√ºr jede Ebenes
|  pr√ºfe f√ºr alle Pr√§diktoren alle m√∂glichen Bedingungen
|  w√§hle denjenigen Pr√§diktor mit derjenigen Bedingung, der die Homogenit√§t maximiert
solange bis Abbruchkriterium erreicht ist.
```

Ein Bedingung k√∂nnte sein `Age >= 18` oder `Years < 4.5`.

Es kommen mehrere Abbruchkriterium in Frage:

- Eine Mindestanzahl von Beobachtungen pro Knoten wird unterschritten (`minsplit`)
- Die maximale Anzahl an Ebenen ist erreicht (`maxdepth`)
- Die minimale Zahl an Beobachtungen eines Blatts wird unterschritten (`minbucket`)



Der Gini-Koeffizient ist im Fall einer UV mit zwei Stufen, $c_A$ und $c_B$, so definiert:

$$G = 1 - \left(p(c_A)^2 + (1-p(c_A))^2\right)$$


Der Algorithmus ist "gierig" (greedy): Optimiert werden lokal optimale Aufteilungen,
auch wenn das bei sp√§teren Aufteilungen im Baum dann insgesamt zu geringerer Homogenit√§t f√ºhrt.


Die Entropie ist definiert als 

$$D = - \sum_{k=1}^K p_k \cdot log(p_k),$$

wobei $K$ die Anzahl der Kategorien indiziert.

Gini-Koeffizient und Entropie kommen oft zu √§hnlichen numerischen Ergebnissen,
so dass wir uns im Folgenden auf den Gini-Koeffizienten konzentieren werden.

---

*Beispiel*

Vergleichen wir drei Bedingungen mit jeweils $n=20$ F√§llen, die zu unterschiedlich homogenen Knoten f√ºhren:

- 10/10
- 15/5
- 19/1

Was ist jeweils der Wert des Gini-Koeffizienten?


```{r echo = TRUE}
G1 <- 1 - ((10/20)^2 + (10/20)^2)
G1

G2 <- 1 - ((15/20)^2 + (5/20)^2)
G2

G3 <- 1 - ((19/20)^2 + (1/20)^2)
G3
```


Wie man sieht, sinkt der Wert des Gini-Koeffizienten ("G-Wert"), je homogener die Verteilung ist.
*Maximal* heterogen ("gemischt") ist die Verteilung, wenn alle Werte gleich oft vorkommen,
in diesem Fall also 50%/50%.


---


Neben dem G-Wert f√ºr einzelne Knoten kann man den G-Wert f√ºr eine Aufteilung ("Split") berechnen,
also die Fraeg beantworten, ob die Aufteilung eines Knoten in zwei zu mehr Homogenit√§t f√ºhrt.
Der G-Wert einer Aufteilung ist die gewichtete Summe der G-Werte der beiden Knoten (links, $l$ und rechts, $r$):


$$G_{split} = p(l) G_{l} + p(r) G_r$$

Der *Gewinn* (gain) an Homogenit√§t ist dann die Differenz des G-Werts der kleineren Ebene und der Aufteilung:


$$G_{gain} = G - G_{split}$$






Der Algorithmus kann auch bei UV mit mehr als zwei, also $K$ Stufen, $c_1, c_2, \ldots, c_K$ verwendet werden:


$$G= 1- \sum_{k=1}^K p(c_k)^2$$ 



### Metrische Pr√§diktoren


Au√üerdem ist es m√∂glich, Bedingung  bei *metrischen* UV auf ihre Homogenit√§t hin zu bewerten,
also Aufteilungen der Art `Years < 4.5` zu t√§tigen. 
Dazu muss man einen Wert identifieren, bei dem man auftrennt.

Das geht in etwa so:

```
Sortiere die Werte eines Pr√§diktors (aufsteigend)
F√ºr jedes Paar an aufeinanderfolgenden Werten berechne den G-Wert
Finde das Paar mit dem h√∂chsten G-Wert aus allen Paaren
Nimm den Mittelwert der beiden Werte dieses Paares: Das ist der Aufteilungswert
```


Abbildung @fig-tree-metr stellt dieses Vorgehen schematisch dar [@rhys].


```{r tree-metr, fig.cap = "Aufteilungswert bei metrischen Pr√§diktoren"}
#| label: fig-tree-metr
#| echo: false
knitr::include_graphics("img/fig7-5_alt.jpeg")
```


## Regressionb√§ume

Bei Regressionsb√§umen wird nicht ein Homogenit√§tsma√ü wie der Gini-Koeffizient als Optimierungskriterium
herangezogen, sondern die *RSS* (Residual Sum of Squares) bietet sich an.

Die $J$ Regionen (Partionierungen) des Pr√§diktorraums $R_1, R_2, \ldots, R_J$ m√ºssen so gew√§hlt werden,
dass RSS minimal ist:


$$RSS = \sum^J_{j=1}\sum_{i\in R_j}(u_i - \hat{y}_{R_j})^2,$$

wobei $\hat{y}$ der (vom Baum) vorhergesagte Wert ist f√ºr die $j$-te Region.


## Baum beschneiden

Ein Problem mit Entscheidungsb√§umen ist,
dass ein zu komplexer Baum, "zu ver√§stelt" sozusagen,
in hohem Ma√üe Overfitting ausgesetzt ist:
Bei h√∂heren Ebenen im Baum ist die Anzahl der Beobachtungen zwangsl√§ufig klein,
was bedeutet, dass viel Rauschen gefittet wird.

Um das Overfitting zu vermeiden, gibt es zwei auf der Hand liegende Ma√ünahmen:

1. Den Baum nicht so gro√ü werden lassen
2. Den Baum "zur√ºckschneiden"

Die 1. Ma√ünahme beruht auf dem Festlegen einer maximalen Zahl an Ebenen (`maxdepth`) oder einer minimalen Zahl an F√§llen pro Knoten (`minsplit`) oder im Blatt (`minbucket`).


Die 2. Ma√ünahme, das Zur√ºckschneiden (pruning) des Baumes hat als Idee, einen "Teilbaum" $T$ zu finden,
der so klein wie m√∂glich ist, aber so gut wie m√∂glich pr√§zise Vorhersagen erlaubt.
Dazu belegen wir die RSS eines Teilbaums (subtree) mit einem Strafterm $s = \alpha |T|$,
wobei $|T|$ die Anzahl der Bl√§tter des Baums entspricht. $\alpha$ ist ein Tuningparameter,
also ein Wert, der nicht vom Modell berechnet wird, sondern von uns gesetzt werden muss -
zumeist durch schlichtes Ausprobieren.
$\alpha$ w√§gt ab zwischen Komplexit√§t und Fit (geringe RSS).
Wenn $\alpha=0$ haben wir eine normalen, unbeschnittenen Baum $T_0$.
Je gr√∂√üer $\alpha$ wird, desto h√∂her wird der "Preis" f√ºr viele Bl√§tter, also f√ºr Komplexit√§t
und der Baum wird kleiner.
Dieses Vorgehen nennt man auch *cost complexity pruning*.
Daher nennt man den zugeh√∂rigen Tuningparameter auch *Cost Complexity* $C_p$.



## Das Rechteck schl√§gt zur√ºck


Entscheidungsb√§ume zeichnen sich durch rechtecke (rekursive) Partionierungen des Pr√§diktorenraums aus.
Lineare Modelle durch eine einfache lineare Partionierung (wenn man Klassifizieren m√∂chte),
 @fig-rechteck verdeutlicht diesen Unterschied [@islr].


```{r rechteck, fig.cap = "Rechteckige vs. lineare Partionierung", echo = FALSE}
#| label: fig-rechteck 
knitr::include_graphics("img/8.7.png")
```

Jetzt kann sich fragen: Welches Vorgehen ist besser - das rechteckige oder das lineare Partionierungen.
Da gibt es eine klare Antwort: Es kommt drauf an.
Wie  @fig-rechteck gibt es Datenlagen, in denen das eine Vorgehen zu homogenerer Klassifikation f√ºhrt
und Situationen, in denen das andere Vorgehen besser ist.


```{r lunch, fig.cap = "Free Lunch?", out.width="30%", echo = FALSE}
#| label: fig-lunch
#| eval: false
knitr::include_graphics("http://hephaestus-associates.com/wp-content/uploads/2016/07/What-if-I-told-You-There-is-no-Such-Thing-as-a-Free-Lunch-300x300.jpg")
```




## Tidymodels


Probieren wir den Algorithmus Entscheidungsb√§ume an einem einfachen Beispiel in R mit Tidymodels aus.

Die Aufgabe sei, Spritverbrauch (m√∂glichst exakt) vorherzusagen.

Ein √§hnliches Beispiel, mit analogem Vorgehen, findet sich in [dieser Fallstude](https://juliasilge.com/blog/wind-turbine/).



### Initiale Datenaufteilung


```{r echo = TRUE}
library(tidymodels)
```


```{r warning=TRUE, echo = TRUE}
data("mtcars")

set.seed(42)  # Reproduzierbarkeit
d_split <- initial_split(mtcars, strata = mpg)

d_train <- training(d_split)
d_test <- testing(d_split)
```


Die Warnung zeigt uns, dass der Datensatz sehr klein ist; stimmt. Ignorieren wir hier einfach.

Wie man auf der [Hilfeseite der Funktion](https://rsample.tidymodels.org/reference/initial_split.html) sieht,
wird per Voreinstellung 3/1 aufgeteilt, also 75% in das Train-Sample, 25% der Daten ins Test-Sample.

Bei $n=32$ finden also 8 Autos ihren Weg ins Test-Sample und die √ºbrigen 24 ins Train-Sample.
Bei der kleinen Zahl k√∂nnte man sich (berechtigterweise) fragen,
ob es Sinn macht, die sp√§rlichen Daten noch mit einem Test-Sample weiter zu dezimieren.
Der Einwand ist nicht unberechtigt, 
allerdings zieht der Verzicht auf ein Test-Sample andere Probleme, Overfitting namentlich, nach sich.



### Kreuzvalidierung definieren

```{r echo = TRUE}
d_cv <- vfold_cv(d_train, strata = mpg, repeats = 5, v = 5) 
d_cv
```

Die Defaults (Voreinstellungen) der Funktion `vfold_cv()` k√∂nnen, wie immer, auf der [Hilfeseite der Funktion](https://rsample.tidymodels.org/reference/vfold_cv.html) nachgelesen werden.

Da die Stichprobe sehr klein ist,
bietet es sich an, eine kleine Zahl an Faltungen (`folds`) zu w√§hlen.
Bei 10 Faltungen beinhaltete eine Stichprobe gerade 10% der F√§lle in Train-Sample,
also etwa ... 2!


Zur Erinnerung:
Je gr√∂√üer die Anzahl der Repeats,
desto genauer sch√§tzen wir die Modellg√ºte.


### Rezept definieren

Hier ein einfaches Rezept:

```{r echo = TRUE}
recipe1 <-
  recipe(mpg ~ ., data = d_train) %>% 
  step_impute_knn() %>% 
  step_normalize() %>% 
  step_dummy() %>% 
  step_other(threshold = .1)
```



### Modell definieren

```{r echo = TRUE}
tree_model <-
  decision_tree(
    cost_complexity = tune(),
    tree_depth = tune(),
    min_n = tune()
  ) %>% 
  set_engine("rpart") %>% 
  set_mode("regression")
  
```


Wenn Sie sich fragen, woher Sie die Optionen f√ºr die Tuningparameter wissen sollen: Schauen Sie mal in die [Hilfeseite des Pakets {{dials}}](https://dials.tidymodels.org/articles/Basics.html); das Paket ist Teil von Tidymodels.


Die Berechnung des Modells l√§uft √ºber das Paket `{{rpart}}`, 
was wir durch `set_engine()` festgelegt haben.


Der Parameter *Cost Complexity*, $C_p$ oder manchmal auch mit $\alpha$ bezeichnet,
hat einen typischen Wertebereich von $10^{-10}$ bis $10^{-1}$:


```{r echo = TRUE}
cost_complexity()
```


Hier ist der Wert in Log-Einheiten angegeben. Wenn Sie sich fragen, woher Sie das bittesch√∂n wissen sollen:
Naja, es steht auf der [Hilfeseite](https://dials.tidymodels.org/articles/Basics.html) üòÑ.

Unser Modell ist also so definiert:

```{r echo = TRUE}
tree_model
```


Mit `tune()` weist man den betreffenden Parameter als "zu tunen" aus -
gute Werte sollen durch Ausprobieren w√§hrend des Berechnens bestimmt werden.
Genauer gesagt soll das Modell f√ºr jeden Wert (oder jede Kombination an Werten von Tuningparametern)
berechnet werden.

Eine Kombination an Tuningparameter-Werten, die ein Modell spezifizieren,
sozusagen erst "fertig definieren", nennen wir einen *Modellkandidaten*.


Definieren wir also eine Tabelle (`grid`) mit Werten, die ausprobiert, "getuned" werden sollen.
Wir haben oben dre Tuningparameter bestimmt. Sagen wir,
wir h√§tten gerne jeweils 5 Werte pro Parameter.


```{r echo = TRUE}
tree_grid <-
  grid_regular(
    cost_complexity(),
    tree_depth(),
    min_n(),
    levels = 4
  )
```


F√ºr jeden Parameter sind Wertebereiche definiert;
dieser Wertebereich wird gleichm√§√üig (daher `grid regular`) aufgeteilt;
die Anzahl der verschiedenen Werte pro Parameter wird druch `levels` gegeben.


Mehr dazu findet sich auf der [Hilfeseite](https://dials.tidymodels.org/reference/grid_regular.html) zu `grid_regular()`.

Wenn man die alle miteinander durchprobiert, entstehen $4^3$ Kombinationen,
also Modellkandidaten. 

Allgemeiner gesagt sind das bei $n$ Tuningparametern mit jeweils $m$ verschiedenen Werten $m^n$ M√∂glichkeiten,
spricht Modellkandidaten. Um diesen Faktor erh√∂ht sich die Rechenzeit im Vergleich zu einem Modell ohne Tuning.
Man sieht gleich, dass die Rechenzeit schnell unangenehm lang werden kann.

Entsprechend hat unsere Tabelle diese Zahl an Zeilen.
Jede Zeile definiert einen Modellkandidaten,
also eine Berechnung des Modells.

```{r echo = TRUE}
dim(tree_grid)
```

```{r echo = TRUE}
head(tree_grid)
```



Man beachte, dass au√üer *Definitionen* bisher nichts passiert ist -- vor allem haben wir noch
nichts berechnet.
Sie scharren mit den Hufen? Wollen endlich loslegen?
Also gut.


### Workflow definieren


Fast vergessen: Wir brauchen noch einen Workflow.


```{r echo = TRUE}
tree_wf <-
  workflow() %>% 
  add_model(tree_model) %>% 
  add_recipe(recipe1)
```




### Modell tunen und berechnen

Achtung: Das Modell zu berechnen kann etwas dauern.
Es kann daher Sinn machen, 
das Modell abzuspeichern,
so dass Sie beim erneuten Durchlaufen nicht nochmal berechnen m√ºssen,
sondern einfach von der Festplatte laden k√∂nnen;
das setzt nat√ºrlich voraus,
dass sich am Modell nichts ge√§ndert hat.



```{r eval = FALSE, message=FALSE, warning=FALSE, echo = TRUE, results = "hide"}
doParallel::registerDoParallel()  # mehrere Kerne parallel nutzen

set.seed(42)
tic()  # Stoppuhr an
trees_tuned <-
  tune_grid(
    object = tree_wf,
    grid = tree_grid,
    resamples = d_cv
  )
toc()  # Stoppuhr aus
```




Es bietet sich vielleicht in dem Fall an, das Ergebnis-Objekt als *R Data serialized* (rds) abzuspeichern:

```{r eval = FALSE, echo = TRUE}
write_rds(trees_tuned, "objects/trees1.rds")
```

Bzw. so wieder aus der RDS-Datei zu importieren:

```{r echo = TRUE}
trees_tuned <- read_rds("objects/trees1.rds")
```


:::{.callout-note}
Das Zwischenspeichern von Modellobjekten ist praktisch, weil es Rechenzeit spart.
Allerdings hat es auch Nachteile: Wenn Sie Ihre Modellspezifikation √§ndern,
m√ºssen Sie auch Ihr gespeichertes Modell aktualisieren. Das vergisst man leicht.
Dann hat man falsche Ergebnisse und man wird nicht durch eine Fehlermeldung gewarnt.
:::


[Hier](https://stackoverflow.com/questions/21370132/what-are-the-main-differences-between-r-data-files) oder [hier](https://en.wikipedia.org/wiki/Serialization) kann man einiges zum Unterschied einer RDS-Datei vs. einer "normalen" R-Data-Datei nachlesen.
Wenn man m√∂chte üòâ.




```{r echo = TRUE}
trees_tuned
```


Die Warnhinweise kann man sich so ausgeben lassen:

```{r echo = TRUE}
collect_notes(trees_tuned)
```


Wie gesagt,
in diesem Fall war die Stichprobengr√∂√üe sehr klein.




### Modellg√ºte evaluieren


```{r echo = TRUE}
collect_metrics(trees_tuned)
```


Praktischerweise gibt es eine Autoplot-Funktion, um die besten Modellparameter auszulesen:

```{r echo = TRUE, fig.width = 10}
autoplot(trees_tuned)
```


### Bestes Modell ausw√§hlen

Aus allen Modellkandidaten w√§hlen wir jetzt das beste Modell aus:


```{r echo = TRUE}
select_best(trees_tuned)
```


Mit diesem besten Kandidaten definieren wir jetzt das "finale" Modell,
wir "finalisieren" das Modell mit den besten Modellparametern:


```{r echo = TRUE}
tree_final <-
  finalize_model(tree_model, parameters = select_best(trees_tuned))

tree_final
```

Hier ist, unser finaler Baum üå≥.


Schlie√ülich updaten wir mit dem finalen Baum noch den Workflow:


```{r echo = TRUE}
final_wf <-
  tree_wf %>% 
  update_model(tree_final)
```


### Final Fit

Jetzt fitten wir dieses Modell auf das *ganze* Train-Sample und predicten auf das Test-Sample:



```{r echo = TRUE}
tree_fit_final <-
  final_wf %>% 
  last_fit(d_split)

tree_fit_final
```


```{r echo = TRUE}
collect_metrics(tree_fit_final)
```


Voil√†: Die Modellg√ºte f√ºr das Test-Sample:
Im Schnitt liegen wir ca. 4 Meilen daneben mit unseren Vorhersagen,
wenn wir RMSE mal so locker interpretieren wollen.

In der Regel ist √ºbrigens RMSE interessanter als R-Quadrat,
da R-Quadrat die G√ºte eines Korrelationsmusters vorhersagt,
aber RMSE die Pr√§zision der Vorhersage,
also sozusagen die K√ºrze der Fehlerbalken.


### Nur zum Spa√ü: Vergleich mit linearem Modell

Ein einfaches lineares Modell,
was h√§tte das jetzt wohl f√ºr eine Modellg√ºte?




```{r echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r}
lm_model <-
  linear_reg()
```


```{r}
lm_wf <-
  workflow() %>% 
  add_model(lm_model) %>% 
  add_recipe(recipe1)
```


```{r}
tic()
lm_fit <-
  fit_resamples(
    lm_wf,
    resamples = d_cv
  )
toc()
```



```{r}
collect_metrics(lm_fit)
```


```{r}
lm_fit_final <- 
  last_fit(lm_wf, d_split)
```


Wie pr√§zise ist die Vorhersage im Test-Sample?

```{r}
collect_metrics(lm_fit_final)
```

Das lineare Modell schneidet etwas (deutlich?) schlechter ab als das einfache Baummodell.


Man beachte, dass die Modellg√ºte im Train-Samle h√∂her ist als im Test-Sample (Overfitting).









##  Vertiefung

- [Visualisierung des ML-Ablaufs am Beispiel des Entscheidungsbaums, Teil 1](http://www.r2d3.us/visual-intro-to-machine-learning-part-1/)
- [Visualisierung des ML-Ablaufs am Beispiel des Entscheidungsbaums, Teil 2](http://www.r2d3.us/visual-intro-to-machine-learning-part-2/)


##   Aufgaben

- [Fallstudie Oregon Schools](https://bcullen.rbind.io/post/2020-06-02-tidymodels-decision-tree-learning-in-r/)
- [Fallstudie Windturbinen](https://juliasilge.com/blog/wind-turbine/)
- [Fallstudie Churn](https://www.gmudatamining.com/lesson-13-r-tutorial.html)
   
